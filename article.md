_Данная статья распространяется на условиях лицензии [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)_

# Считаем числа на русском

В рамках этой статьи мы шаг за шагом напишем на [Rust](rust-lang.org) программу, решающую следующую задачу:

> На вход подаётся неотрицательное целое число `n < 1 000 000 000`. Вывести название этого числа на русском языке.
> Пример:
> 
>     23 -> двадцать три
>     120 000 -> сто двадцать тысяч
>     41 201 009 -> сорок один миллион двести одна тысяча девять
>
> Отдельные слова должны быть согласованы друг с другом по роду и числу.
> Использование `ноль` допускается только для числа `0` и не допускается на местах нулевых цифр.
> Слова должны быть отделены пробелами. Пробелы в начале и в конце результирующей строки не допускается.
> Числа от 11 до 19 включительно должны быть корректно обработаны (то есть, например, `тринадцать`, а не `десять три`)

Конечно, условия довольно жёсткие. Но не переживайте, мы с вами начём с малого и постепеннно получим решение задачи, попутно ознакомившись с фичами Rust-а (если вы всё же хотите увидеть решение целиком сразу — прокрутите в конец статьи). Все примеры кода в статье зависят только от стандартной библиотеки. По ходу чтения вы можете запускать их на [интерактивном playground-е](play.rust-lang.org). Итак, поехали!

## Самые азы

Окей, исходная задача слишком сложна, чтобы её можно было сразу решить. Начнём с чего-нибудь попроще, а именно, с чисел от одного до девяти:

```
fn print_number(n: u32) {
    match n {
        1 => print!("один"),
        2 => print!("два"),
        3 => print!("три"),
        4 => print!("четыре"),
        5 => print!("пять"),
        6 => print!("шесть"),
        7 => print!("семь"),
        8 => print!("восемь"),
        9 => print!("девять"),
        _ => print!("это не цифра"),
    }
}

fn main() {
    print_number(1);
    println!();
    print_number(7);
}
```

_[Запустить](fn%20print_number(n%3A%20u32)%20%7B%0A%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20print!(%22%D0%BD%D0%BE%D0%BB%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%201%20%3D%3E%20print!(%22%D0%BE%D0%B4%D0%B8%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%202%20%3D%3E%20print!(%22%D0%B4%D0%B2%D0%B0%22)%2C%0A%20%20%20%20%20%20%20%203%20%3D%3E%20print!(%22%D1%82%D1%80%D0%B8%22)%2C%0A%20%20%20%20%20%20%20%204%20%3D%3E%20print!(%22%D1%87%D0%B5%D1%82%D1%8B%D1%80%D0%B5%22)%2C%0A%20%20%20%20%20%20%20%205%20%3D%3E%20print!(%22%D0%BF%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%206%20%3D%3E%20print!(%22%D1%88%D0%B5%D1%81%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%207%20%3D%3E%20print!(%22%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%208%20%3D%3E%20print!(%22%D0%B2%D0%BE%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%209%20%3D%3E%20print!(%22%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20print!(%22%D1%8D%D1%82%D0%BE%20%D0%BD%D0%B5%20%D1%86%D0%B8%D1%84%D1%80%D0%B0%22)%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20print_number(1)%3B%0A%20%20%20%20println!()%3B%0A%20%20%20%20print_number(7)%3B%0A%20%20%20%20print!(%22%5Cn%7B%7D%22%2C%20u32%3A%3Amax_value())%3B%0A%7D)_

Окей, давайте разберём, что тут происходит (если вы уже знакомы с синтаксисом Rust, можете спокойно пропустить этот абзац). Ключевое слово `fn` (сокращение от `function`) определяет функцию. За ним следует имя функции — `print_number`. За ним в скобках перечисляются аргументы функции. У этой функции параметр только один — `n`, число, которое нам надо распечатать. После двоеточия следует _тип_ переменной. В нашем случае это `u32`, т. е. 32-битное беззнаковое целое число (такое число может вместить миллиард). За этим заголовком функции в фигурных скобках следует её тело. Тело состоит из одного выражения `match`. Оно принимает `n` и выполняет различный код в зависимости от его значения. В фигурных скобках после `match n` идут различные ветви исполнения. Слева от стрелки `=>` находится выражение, с которым сопоставляется `n`, а справа от стрелки — исполняемый при выборе этой ветки код. Когда исполнение доходит до `match`, значение `n` сопоставляется с выражением слева от стрелки и для первого подходящего выражения исполняется соответствующий код. В отличие от конструкции `switch` в C (и других подобных языках), остальные ветви ниже при этом не исполняются.
