_Данная статья распространяется на условиях лицензии [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)_

# Считаем числа на русском

В рамках этой статьи мы шаг за шагом напишем на [Rust](rust-lang.org) программу, решающую следующую задачу:

> На вход подаётся неотрицательное целое число `n < 1 000 000 000`. Вывести название этого числа на русском языке.
> Пример:
> 
>     23 -> двадцать три
>     120 000 -> сто двадцать тысяч
>     41 201 009 -> сорок один миллион двести одна тысяча девять
>
> Отдельные слова должны быть согласованы друг с другом по роду и числу.
> Использование `ноль` допускается только для числа `0` и не допускается на местах нулевых цифр.
> Слова должны быть отделены пробелами. Пробелы в начале и в конце результирующей строки не допускается.
> Числа от 11 до 19 включительно должны быть корректно обработаны (то есть, например, `тринадцать`, а не `десять три`)

Конечно, условия довольно жёсткие. Но не переживайте, мы с вами начём с малого и постепеннно получим решение задачи, попутно ознакомившись с фичами Rust-а (если вы всё же хотите увидеть решение целиком сразу — прокрутите в конец статьи). Все примеры кода в статье зависят только от стандартной библиотеки. По ходу чтения вы можете запускать их на [интерактивном playground-е](play.rust-lang.org). Итак, поехали!

## Слишком сложно

Окей, исходная задача слишком сложна, чтобы её можно было сразу решить. Начнём с чего-нибудь попроще, а именно, с чисел от одного до девяти:

```
fn print_number(n: u32) {
    match n {
        1 => print!("один"),
        2 => print!("два"),
        3 => print!("три"),
        4 => print!("четыре"),
        5 => print!("пять"),
        6 => print!("шесть"),
        7 => print!("семь"),
        8 => print!("восемь"),
        9 => print!("девять"),
        _ => print!("это не цифра"),
    }
}

fn main() {
    print_number(1);
    println!();
    print_number(7);
}
```

_[Запустить](fn%20print_number(n%3A%20u32)%20%7B%0A%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20print!(%22%D0%BD%D0%BE%D0%BB%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%201%20%3D%3E%20print!(%22%D0%BE%D0%B4%D0%B8%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%202%20%3D%3E%20print!(%22%D0%B4%D0%B2%D0%B0%22)%2C%0A%20%20%20%20%20%20%20%203%20%3D%3E%20print!(%22%D1%82%D1%80%D0%B8%22)%2C%0A%20%20%20%20%20%20%20%204%20%3D%3E%20print!(%22%D1%87%D0%B5%D1%82%D1%8B%D1%80%D0%B5%22)%2C%0A%20%20%20%20%20%20%20%205%20%3D%3E%20print!(%22%D0%BF%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%206%20%3D%3E%20print!(%22%D1%88%D0%B5%D1%81%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%207%20%3D%3E%20print!(%22%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%208%20%3D%3E%20print!(%22%D0%B2%D0%BE%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%209%20%3D%3E%20print!(%22%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20print!(%22%D1%8D%D1%82%D0%BE%20%D0%BD%D0%B5%20%D1%86%D0%B8%D1%84%D1%80%D0%B0%22)%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20print_number(1)%3B%0A%20%20%20%20println!()%3B%0A%20%20%20%20print_number(7)%3B%0A%20%20%20%20print!(%22%5Cn%7B%7D%22%2C%20u32%3A%3Amax_value())%3B%0A%7D)_

## Самые азы

Окей, давайте разберём, что тут происходит (если вы уже знакомы с основами Rust, можете спокойно пропустить этот параграф).

Ключевое слово `fn` (сокращение от `function`) определяет функцию. За ним следует имя функции — `print_number`. За ним в скобках перечисляются аргументы функции. У этой функции параметр только один — `n`, число, которое нам надо распечатать. После двоеточия следует _тип_ переменной. В нашем случае это `u32`, т. е. 32-битное беззнаковое целое число (такое число может вместить миллиард). После заголовка идёт тело функции в фигурных скобках. Складывая всё вместе, получаем, что функция `print_number` принимает в качестве аргумента 32-битное беззнаковое число и, т. к. тип возвращаемоего значения не задан явно, возвращает [`()` (unit)](https://doc.rust-lang.org/stable/std/primitive.unit.html).

Тело функции состоит из одного выражения `match`. Оно принимает `n` и выполняет различный код в зависимости от его значения. В фигурных скобках после `match n` идут различные ветви исполнения. Слева от стрелки `=>` находится паттерн, с которым сопоставляется `n`, а справа от стрелки — исполняемый при выборе этой ветки код. Когда исполнение доходит до `match`, значение `n` сопоставляется с паттерном слева от стрелки и для первого подходящего паттерна исполняется соответствующий код (в отличие от конструкции `switch` в C и других подобных языках, остальные ветви ниже при этом не исполняются).

Синтаксис `имя!` обозначает макрос. В Rust макрос [`print!`](https://doc.rust-lang.org/stable/std/macro.print.html) разворачивается в код, который выводит переданые аргументы на стандартный вывод. Перевод строки в конце при этом не добавляется (этим он отличается от [`println!`](https://doc.rust-lang.org/stable/std/macro.println.html)).

Т. о.,  для `n` проверяется, что это число в пределах десятка, и если это так, выводится название числа на русском языке. Если этого не происходит, то значение `n` сопоставляется с паттерном `_` (который подходит под любое значение) и выводится сообщение о том, что переданное значение не является цифрой. Эта ветвь является обязательной — попробуйте убрать эту строку и [посмотреть, что получится](https://play.rust-lang.org/?code=fn%20print_number(n%3A%20u32)%20%7B%0A%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%201%20%3D>%20print!("один")%2C%0A%20%20%20%20%20%20%20%202%20%3D>%20print!("два")%2C%0A%20%20%20%20%20%20%20%203%20%3D>%20print!("три")%2C%0A%20%20%20%20%20%20%20%204%20%3D>%20print!("четыре")%2C%0A%20%20%20%20%20%20%20%205%20%3D>%20print!("пять")%2C%0A%20%20%20%20%20%20%20%206%20%3D>%20print!("шесть")%2C%0A%20%20%20%20%20%20%20%207%20%3D>%20print!("семь")%2C%0A%20%20%20%20%20%20%20%208%20%3D>%20print!("восемь")%2C%0A%20%20%20%20%20%20%20%209%20%3D>%20print!("девять")%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20print_number(1)%3B%0A%20%20%20%20println!()%3B%0A%20%20%20%20print_number(7)%3B%0A%7D).

Обратите внимание, в конце кода функции нет `return`.

## Разбор полётов

Рассмотренное решение достаточно простое, но оно обладает рядом недостатков (это помимо того, что оно не решает изначальную задачу).

Во-первых, оно не масштабируется. Мы бы, конечно, могли бы написать выражение на русском для _каждого_ числа от нуля до миллиона, но это не наш вариант, т. к. мы программисты умные, а главное, ленивые. Зачем писать руками то, что можно заставить писать компьютер? 

Во-вторых, оно негибкое. Сейчас решение выводит строки в стандартный вывод. В реальной программе же, скорее всего, нам было бы удобнее сохранить промежуточный результат в виде строки и уже потом, по необходимости, вывести на печать. Текущее решение не позволяет это сделать. И вообще, считается хорошей идеей [отделять побочные эффекты и исполнять их только в последний момент, когда это действительно требуется](https://www.youtube.com/watch?v=GqmsQeSzMdw).

В-третьих, это решение принципиально неполное. Что делать, если `n` окажется больше девяти? Здесь я выбрал выводить сообщение о том, что число не является цифрой, но оно явно неудовлетворительно (представьте себе надпись на сайте онлайн-магазина "У вас в корзине это не цифра товаров"). Что ещё мы можем сделать?
* Мы можем [возбудить панику](https://doc.rust-lang.org/stable/std/macro.panic.html) (примерный эквивалент генерации исключения в других языках). Этот вариант не годится, т. к., во-первых, из сигнатуры функции не видно, что она может бросать панику, во-вторых, потому что паники дорого бросать, и в-третьих, в Rust перехватывать панику неудобно, равно как и получать из неё иформацию;
* Мы можем выводить пустую строку. Это тоже не очень хороший вариант, т. к. пользователь функции будет либо проверять тот факт, что `n` лежит в нужном диапазоне (и таким образом дублировать проверки в функции), либо не будет — что вполне может произойти просто по ошибке — и таким образом будет сильно удивлён, когда функция не произведёт никакого вывода вообще;
* Мы можем выводить пустую строку и заодно возвращать булевское значение, сигнализирующее о том, была ли произведена печать. Также сомнительный вариант — значение, возвращаемое функцией, можно с лёгкостью проигнорировать, вдобавок булевское значение без контекста не несёт вообще никакой информации ("Эта функция возвращает `true`, когда _выводит_ что-то на печать или же наоборот? Чёрт, не помню, нужно опять посмотреть в документации").

Что же нам делать? Нам нужно решение, которое смогло бы:
1. Отделить побочные эффекты;
2. Явно закодировать конечность входного диапазона (желательно с проверками на этапе компиляции).

Второй пункт проистекает из того, что мы взяли тип `u32` — со слишком широким диапазоном значений и потому плохо выражающий наши намерения. Чтобы решить это затруднение, мы создадим свой тип, и как будет видно из дальнейшего, он поможет решить и проблему из первого пункта.

