_Данная статья распространяется на условиях лицензии [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)_

# Считаем числа на русском

В рамках этой статьи мы шаг за шагом напишем на [Rust](rust-lang.org) программу, решающую следующую задачу:

> На вход подаётся неотрицательное целое число `n < 1 000 000 000`. Вывести название этого числа на русском языке.
> Пример:
> 
>     23 -> двадцать три
>     120 000 -> сто двадцать тысяч
>     41 201 009 -> сорок один миллион двести одна тысяча девять
>
> Отдельные слова должны быть согласованы друг с другом по роду и числу.
> Использование `ноль` допускается только для числа `0` и не допускается на местах нулевых цифр.
> Слова должны быть отделены пробелами. Пробелы в начале и в конце результирующей строки не допускается.
> Числа от 11 до 19 включительно должны быть корректно обработаны (то есть, например, `тринадцать`, а не `десять три`)

Конечно, условия довольно жёсткие. Но не переживайте, мы с вами начём с малого и постепеннно получим решение задачи, попутно ознакомившись с фичами Rust-а (если вы всё же хотите увидеть решение целиком сразу — прокрутите в конец статьи). Все примеры кода в статье зависят только от стандартной библиотеки. По ходу чтения вы можете запускать их на [интерактивном playground-е](play.rust-lang.org). Итак, поехали!

## Слишком сложно!

Ладно, исходная задача слишком сложна, чтобы её можно было сразу решить. Начнём с чего-нибудь попроще, а именно, с чисел от одного до девяти:

```rust
fn print_number(n: u32) {
    match n {
        1 => print!("один"),
        2 => print!("два"),
        3 => print!("три"),
        4 => print!("четыре"),
        5 => print!("пять"),
        6 => print!("шесть"),
        7 => print!("семь"),
        8 => print!("восемь"),
        9 => print!("девять"),
        _ => print!("это не цифра"),
    }
}

fn main() {
    print_number(1);
    println!();
    print_number(7);
}
```

_[Запустить](fn%20print_number(n%3A%20u32)%20%7B%0A%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20print!(%22%D0%BD%D0%BE%D0%BB%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%201%20%3D%3E%20print!(%22%D0%BE%D0%B4%D0%B8%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%202%20%3D%3E%20print!(%22%D0%B4%D0%B2%D0%B0%22)%2C%0A%20%20%20%20%20%20%20%203%20%3D%3E%20print!(%22%D1%82%D1%80%D0%B8%22)%2C%0A%20%20%20%20%20%20%20%204%20%3D%3E%20print!(%22%D1%87%D0%B5%D1%82%D1%8B%D1%80%D0%B5%22)%2C%0A%20%20%20%20%20%20%20%205%20%3D%3E%20print!(%22%D0%BF%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%206%20%3D%3E%20print!(%22%D1%88%D0%B5%D1%81%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%207%20%3D%3E%20print!(%22%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%208%20%3D%3E%20print!(%22%D0%B2%D0%BE%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%209%20%3D%3E%20print!(%22%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20print!(%22%D1%8D%D1%82%D0%BE%20%D0%BD%D0%B5%20%D1%86%D0%B8%D1%84%D1%80%D0%B0%22)%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20print_number(1)%3B%0A%20%20%20%20println!()%3B%0A%20%20%20%20print_number(7)%3B%0A%20%20%20%20print!(%22%5Cn%7B%7D%22%2C%20u32%3A%3Amax_value())%3B%0A%7D)_

## Самые азы

Окей, давайте разберём, что тут происходит (если вы уже знакомы с основами Rust, можете спокойно пропустить этот параграф).

Ключевое слово `fn` (сокращение от `function`) определяет [функцию](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html). За ним следует имя функции — `print_number`. После него в скобках перечисляются аргументы функции. У этой функции только один параметр — `n`, число, которое нам надо распечатать. После двоеточия следует _тип_ переменной. В нашем случае это `u32`, т. е. 32-битное беззнаковое целое число (такое число может вместить миллиард). После заголовка идёт тело функции в фигурных скобках. Складывая всё вместе, получаем, что функция `print_number` принимает в качестве аргумента 32-битное беззнаковое число и, т. к. тип возвращаемоего значения не задан явно, возвращает [`()` (unit)](https://doc.rust-lang.org/stable/std/primitive.unit.html).

Тело функции состоит из одного выражения [`match`](https://doc.rust-lang.org/book/ch06-02-match.html). Оно принимает `n`, сопоставляет его значение с паттернами в ветках ниже и выполняет код из первой ветки, паттерн которой подходит. В данном случае паттернами являются конкретные числовые значения, которые `n` может принимать. Обратите внимание, в отличие от похожей конструкции `switch` в `C` выполнением одной ветки `match` и ограничивается, т. е. все последующие ветви не исполняются.

Синтаксис `идентификатор!` обозначает макрос. В Rust макрос [`print!`](https://doc.rust-lang.org/stable/std/macro.print.html) разворачивается в код, который выводит переданые аргументы на стандартный вывод. Перевод строки в конце при этом не добавляется (этим он отличается от [`println!`](https://doc.rust-lang.org/stable/std/macro.println.html)).

Т. о.,  для `n` проверяется, что это число не превосходит девяти, и если это так, выводится название числа на русском языке. Если этого не происходит, то значение `n` сопоставляется с паттерном `_` (который подходит под любое значение) и выводится сообщение о том, что переданное значение не является цифрой. Эта ветвь является обязательной — попробуйте убрать эту строку и [посмотреть, что получится](https://play.rust-lang.org/?code=fn%20print_number(n%3A%20u32)%20%7B%0A%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%201%20%3D>%20print!("один")%2C%0A%20%20%20%20%20%20%20%202%20%3D>%20print!("два")%2C%0A%20%20%20%20%20%20%20%203%20%3D>%20print!("три")%2C%0A%20%20%20%20%20%20%20%204%20%3D>%20print!("четыре")%2C%0A%20%20%20%20%20%20%20%205%20%3D>%20print!("пять")%2C%0A%20%20%20%20%20%20%20%206%20%3D>%20print!("шесть")%2C%0A%20%20%20%20%20%20%20%207%20%3D>%20print!("семь")%2C%0A%20%20%20%20%20%20%20%208%20%3D>%20print!("восемь")%2C%0A%20%20%20%20%20%20%20%209%20%3D>%20print!("девять")%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20print_number(1)%3B%0A%20%20%20%20println!()%3B%0A%20%20%20%20print_number(7)%3B%0A%7D).

Обратите внимание, в конце кода функции нет `return`. Т. к. функция объявлена невозвращающей значение, то явно передавать управление обратно не нужно.

## Разбор полётов

Рассмотренное решение достаточно простое, но оно обладает рядом недостатков (это помимо того, что оно не решает изначальную задачу).

Во-первых, оно не масштабируется. Мы бы, конечно, могли бы написать выражение на русском для _каждого_ числа от нуля до миллиона, но это не наш вариант, т. к. мы программисты умные, а главное, ленивые. Зачем писать руками то, что можно заставить писать компьютер? 

Во-вторых, оно негибкое. Сейчас решение выводит строки в стандартный вывод. В реальной программе же, скорее всего, нам было бы удобнее сохранить промежуточный результат в виде строки и уже потом, по необходимости, вывести на печать. Текущее решение не позволяет это сделать. И вообще, считается хорошей идеей [отделять побочные эффекты и исполнять их только в последний момент, когда это действительно требуется](https://www.youtube.com/watch?v=GqmsQeSzMdw).

В-третьих, это решение принципиально неполное. Что делать, если `n` окажется больше девяти? В данной функции я решил выводить сообщение о том, что число не является цифрой, но оно явно неудовлетворительно (представьте себе надпись на сайте онлайн-магазина "У вас в корзине это не цифра товаров"). Что ещё мы можем сделать?
* Мы можем выводить пустую строку. Это тоже не очень хороший вариант, т. к. пользователь функции будет либо проверять тот факт, что `n` лежит в нужном диапазоне (и таким образом дублировать проверки в функции), либо не будет — что вполне может произойти просто по ошибке — и таким образом будет сильно удивлён, когда функция не произведёт никакого вывода вообще;
* Мы можем выводить пустую строку и заодно возвращать булевское значение, сигнализирующее о том, была ли произведена печать. Также сомнительный вариант — значение, возвращаемое функцией, можно с лёгкостью проигнорировать, вдобавок булевское значение без контекста не несёт вообще никакой информации ("Эта функция возвращает `true`, когда _выводит_ что-то на печать, или же наоборот? Чёрт, не помню, нужно опять посмотреть в документации").
* Мы можем [возбудить панику](https://doc.rust-lang.org/stable/std/macro.panic.html) (примерный эквивалент генерации исключения в других языках). Этот вариант тоже не годится, т. к., во-первых, этот механизм предназначен для ситуаций, когда нарушен некий важный инвариант или предусловие (скажем, массивы в Rust паникуют при выходе индекса за границы массива), во-вторых, из сигнатуры функции не видно, что она может бросать панику, в-третьих, потому что паники банально дорого бросать, и в-четвёртых, в Rust перехватывать панику неудобно, равно как и получать из неё иформацию;

Что же нам делать? Нам нужно решение, которое смогло бы:
1. Отделить побочные эффекты;
2. Явно закодировать конечность входного диапазона (желательно с проверками на этапе компиляции).

Второй пункт проистекает из того, что мы взяли тип `u32` — со слишком широким диапазоном значений и потому плохо выражающий наши намерения. Чтобы решить это затруднение, мы создадим свой тип, и как будет видно из дальнейшего, он поможет решить и проблему из первого пункта.

## Считаем на пальцах

Итак, нам нужен строительный кирпичик нашей программы — функция для вывода числа. Для начала объявим тип "цифра":

```rust
#[derive(Clone, Copy)]
pub enum Digit {
    D1 = 0, D2, D3, D4, D5, D6, D7, D8, D9,
}

impl Digit {
    fn new(n: u32) -> Option<Self> {
        use Digit::*;

        const ROW: [Digit; 9] = [D1, D2, D3, D4, D5, D6, D7, D8, D9];

        match n {
            1..=9 => Some(ROW[n as usize - 1]),
            _ => None,
        }
    }
}
```

Разберём по кусочкам:

```rust
#[derive(Clone, Copy)]
enum Digit {
    D1 = 0, D2, D3, D4, D5, D6, D7, D8, D9,
}
```

Ключевое слово `enum` означает, что далее следует объявление [перечисления](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html). После имени типа `Digit` в фигурных скобках следует перечисление (каламбур не намеренный) вариантов значений, которые переменная этого типа может принимать, разделённые запятыми. С перечислениями в Rust удобно работать при помощи конструкции `match`. Компилятор при это проверяет, что проверены все возможные значения, и если какой-то вариант не покрыт паттерном в ветке `match`, то код не компилируется.

Внимательный читатель наверняка заметил, что мы не определили вариант для нуля. Это сделано намеренно: в случае, если в соответствующем разряде стоит `0`, в написании числа не нужно писать никакого слова, поэтому для решения задачи удобнее передавать ноль как отстутствие цифры.

Перечисления в Rust не являются синтаксичесим сахаром для определения численных констант, а являются собственным отдельным типом. Тем не менее, возможность привести перечисление к чису бывает полезным, поэтому после варианта `D1` идёт знак равенства с последующим нулём. Это означает, что значение типа `Digit` можно явным кастом привести к численному типу (`digit as u32`, например). Значение `D1` при этом приводится к нулю, а так как приравнивание числу у других вариантов отсутствует, то значения после каста увеличиваются по порядку (т. е. `D2 as u32 == 1`, `D3 as u32 == 2` и т. д.).

Строка `#[derive(Clone, Copy)]` задаёт автоматическую генерацию [типажей](https://doc.rust-lang.org/book/ch10-02-traits.html) [`Clone`](https://doc.rust-lang.org/stable/std/clone/trait.Clone.html) и [`Copy`](https://doc.rust-lang.org/stable/std/marker/trait.Copy.html). Не углубляясь пока в подробности, скажу, что `Clone` позволяет нам копировать значения `Digit` при помощи метода [`.clone()`](https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone), а `Copy` делает эти копии неявными, что позволяет нам манипулировать значениями `Digit` с тем же удобством, что и с, например, обычными числами.

Перейдём к следующему элементу:

```rust
impl Digit {
    fn new(n: u32) -> Option<Self> {
        //...
    }
}
```

Здесь мы объявляем блок функций, ассоциированных с нашим типом Digit. Внутри мы пишем функцию `new`, которая будет пытаться из целого числа сконструировать `Digit`. В каком-нибудь другом языке мы бы написали конструктор. В Rust на уровне языка нет понятия конструктора, но по соглашению функции, создающие значение некоторого типа, называются `new`. Вызвать мы её можем в виде `Digit::new(5)`.

Т. к. не все 32-битные беззнаковые целые числа укладываются в диапазон от 1 до 9, нам нужно как-то передать тот факт, что создание нового `Digit` может завершиться неудачей. Для этого мы в качестве возвращаемого значения используем стандартный тип [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html). Этот [обобщённый](https://doc.rust-lang.org/book/ch10-01-syntax.html) тип является перечислением с двумя вариантами: `Some` и `None`. `None` означает отсутствие значения, а `Some(val)` — наличие значения `val`. В нашем случае тот факт, что функция вернула `None`, означает, что аргумент лежит вне диапазона от 1 до 9. Т. к. тип `Option` является обобщённым, нам нужно указать, значение какого типа может в нём лежать. Для этого мы пишем после идентификатора в угловых скобках название этого типа. В рамках `impl`-блока мы можем вместо названия типа, для которого мы пишем функции, писать синоним `Self`.

Перейдём к рассмотрению тела функции:

```rust
use Digit::*;
```

Это строчкой вы вносим в текущее пронстранство имён варианты перечисления `Digit`. Это позволяет нам писать `D5` вместо `Digit::D5`.

```rust
const ROW: [Digit; 9] = [D1, D2, D3, D4, D5, D6, D7, D8, D9];
```

Здесь мы объявляем константу `ROW` — массив из всех вариантов `Digit` в порядке возрастания значений. Указать тип константы мы обязаны. После имени константы и двоеточия идёт описание её типа — массив из 9 значений типа `Digit`.

```rust
match n {
    1..=9 => Some(ROW[n as usize - 1]),
    _ => None,
}
```

Тут сосредоточена вся логика по созданию цифры. Сначала мы проверяем, что `n` лежит в диапазоне от 1 до 9 включительно (паттерн вида `low..=high` сопоставляется с любым значением в диапазоне от `low` до `high` включительно). Если это так, то мы возвращаем цифру с номером `n`, иначе мы возвращаем `None`, т. е. тот факт, что цифры нет. Т. к. массивы в Rust, как и в многих других языках, нумеруются с нуля, нам нужно вычесть единицу. Перед этим, однако, нужно привести `n` к типу `usize`, который соответствует машинному типу беззнакового целого. Размер значений этого типа варьирует в зависимости от системы, поэтому его не стоит использовать для хранения величин, которые должны лежать в конкретном достаточно большом диапазоне. Rust очень строг касательно типов переменных и не будет делать неявные преобразования за вас.

Как вы могли заметить, в функции `new` опять нет оператора `return`. Дело в том, что `match` сам по себе является выражением, причём последним в функции, поэтому нет необходимости возвращать значение явно. Конечно, ничто не мешает нам использовать `return`, но такой код в Rust считается неидиоматичным.

Теперь, когда у нас есть возможность создавать цифры, давайте переведём их на русский!

```rust
fn print_digit(digit: Digit) {
    use Digit::*;
    
    match digit {
        D1 => print!("один"),
        D2 => print!("два"),
        D3 => print!("три"),
        D4 => print!("четыре"),
        D5 => print!("пять"),
        D6 => print!("шесть"),
        D7 => print!("семь"),
        D8 => print!("восемь"),
        D9 => print!("девять"),
    }
}

fn main() {
    let five = Digit::new(5);
    
    match five {
        Some(digit) => print_digit(digit),
        None => print!("цифры нет"),
    }
}
```

[Попробуйте запустить!](https://play.rust-lang.org/?code=%23%5Bderive(Clone%2C%20Copy)%5D%0Apub%20enum%20Digit%20%7B%0A%20%20%20%20D1%20%3D%200%2C%20D2%2C%20D3%2C%20D4%2C%20D5%2C%20D6%2C%20D7%2C%20D8%2C%20D9%2C%0A%7D%0A%0Aimpl%20Digit%20%7B%0A%20%20%20%20fn%20new(n%3A%20u32)%20-%3E%20Option%3CSelf%3E%20%7B%0A%20%20%20%20%20%20%20%20use%20Digit%3A%3A*%3B%0A%0A%20%20%20%20%20%20%20%20const%20ROW%3A%20%5BDigit%3B%209%5D%20%3D%20%5BD1%2C%20D2%2C%20D3%2C%20D4%2C%20D5%2C%20D6%2C%20D7%2C%20D8%2C%20D9%5D%3B%0A%0A%20%20%20%20%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%201..%3D9%20%3D%3E%20Some(ROW%5Bn%20as%20usize%20-%201%5D)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20print_digit(digit%3A%20Digit)%20%7B%0A%20%20%20%20use%20Digit%3A%3A*%3B%0A%20%20%20%20%0A%20%20%20%20match%20digit%20%7B%0A%20%20%20%20%20%20%20%20D1%20%3D%3E%20print!(%22%D0%BE%D0%B4%D0%B8%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%20D2%20%3D%3E%20print!(%22%D0%B4%D0%B2%D0%B0%22)%2C%0A%20%20%20%20%20%20%20%20D3%20%3D%3E%20print!(%22%D1%82%D1%80%D0%B8%22)%2C%0A%20%20%20%20%20%20%20%20D4%20%3D%3E%20print!(%22%D1%87%D0%B5%D1%82%D1%8B%D1%80%D0%B5%22)%2C%0A%20%20%20%20%20%20%20%20D5%20%3D%3E%20print!(%22%D0%BF%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20D6%20%3D%3E%20print!(%22%D1%88%D0%B5%D1%81%D1%82%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20D7%20%3D%3E%20print!(%22%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20D8%20%3D%3E%20print!(%22%D0%B2%D0%BE%D1%81%D0%B5%D0%BC%D1%8C%22)%2C%0A%20%20%20%20%20%20%20%20D9%20%3D%3E%20print!(%22%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C%22)%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20five%20%3D%20Digit%3A%3Anew(5)%3B%0A%20%20%20%20%0A%20%20%20%20match%20five%20%7B%0A%20%20%20%20%20%20%20%20Some(digit)%20%3D%3E%20print_digit(digit)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20print!(%22%D1%86%D0%B8%D1%84%D1%80%D1%8B%20%D0%BD%D0%B5%D1%82%22)%2C%0A%20%20%20%20%7D%0A%7D)

Отлично, мы получили то, что хотели — создание цифры отделено от её использования (т. е. ошибка при создании теперь обрабатывается на вызывающей стороне), компилятор заставляет нас обработать все значения `Digit` (попробуйте убрать одну ветвь в `print_digit` и посмотреть, что получится). Мы получили кирпичик, на базе которого мы можем начать строить дальнейшое решение задачи.
